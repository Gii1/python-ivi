from typing import *
from typing_extensions import Final

_prefer_pyvisa: bool

# preference pyvisa
def get_prefer_pyvisa() -> bool: ...
def set_prefer_pyvisa(value: bool = True) -> None: ...

version: str

# Exceptions
class IviException(Exception): ...
class IviDriverException(IviException): ...
class FileFormatException(IviDriverException): ...
class IdQueryFailedException(IviDriverException): ...
class InstrumentStatusExcpetion(IviDriverException): ...
class InvalidOptionValueException(IviDriverException): ...
class IOException(IviDriverException): ...
class IOTimeoutException(IviDriverException): ...
class MaxTimeoutExceededException(IviDriverException): ...
class NotInitializedException(IviDriverException): ...
class OperationNotSupportedException(IviDriverException): ...
class OperationPendingException(IviDriverException): ...
class OptionMissingException(IviDriverException): ...
class OptionStringFormatException(IviDriverException): ...
class OutOfRangeException(IviDriverException): ...
class ResetFailedException(IviDriverException): ...
class ResetNotSupportedException(IviDriverException): ...
class SelectorFormatException(IviDriverException): ...
class SelectorHierarchyException(IviDriverException): ...
class SelectorNameException(IviDriverException): ...
class SelectorNameRequiredException(IviDriverException): ...
class SelectorRangeException(IviDriverException): ...
class SimulationStateException(IviDriverException): ...
class TriggerNotSoftwareException(IviDriverException): ...
class UnexpectedResponseException(IviDriverException): ...
class UnknownOptionException(IviDriverException): ...
class UnknownPhysicalNameException(IviDriverException): ...
class ValueNotSupportedException(IviDriverException): ...

Index = int | str

def get_index(l: list[Index] | dict[Index, int], i: int) -> int:
    """Validate index from list or dict of possible values"""

def get_index_dict(l: list) -> dict[Index, int]:
    """Construct a dict object for faster index lookups"""

T = TypeVar("T")

class PropertyCollection:
    """A building block to create hierarchical trees of methods and properties"""
    def __init__(self) -> None: ...

    def _add_property(self, name: str, fget: Optional[Callable] = None, fset: Optional[Callable] = None, fdel: Optional[Callable] = None, doc: Optional[str] = None) -> None:
        """Add a managed property"""
    def _add_method(self, name: str, f: Optional[Callable] = None, doc: Optional[str] = None) -> None:
        """Add a managed method"""
    def _del_property(self, name: str) -> None:
        """Remove managed property or method"""
    def _lock(self, lock: bool = True) -> None:
        """Set lock state to prevent creation or deletion of unmanaged members"""
    def _unlock(self) -> None:
        """Unlock object to allow creation or deletion of unmanaged members, equivalent to _lock(False)"""

class IndexedPropertyCollection:
    """A building block to create hierarchical trees of methods and properties with an index that is converted to a parameter"""

    def __init__(self) -> None: ...
    def _add_property(self, name: str, fget: Optional[Callable] = None, fset: Optional[Callable] = None, fdel: Optional[Callable] = None, doc: Optional[str] = None, props=None, docs=None) -> None:
        """Add a managed property"""
    def _add_method(self, name, f=None, doc=None, props=None, docs=None) -> None:
        """Add a managed method"""
    def _add_sub_property(self, sub, name, fget=None, fset=None, fdel=None, doc=None) -> None:
        """Add a sub-property (equivalent to _add_property('sub.name', ...))"""
    def _add_sub_method(self, sub, name, f=None, doc=None) -> None:
        """Add a sub-method (equivalent to _add_method('sub.name', ...))"""
    def _del_property(self, name) -> None:
        """Delete property"""
    def _build_obj(self, props, docs, i):
        """Build a tree of PropertyCollection objects with the proper index associations"""
    def _set_list(self, l) -> None:
        """Set a list of allowable indicies as an associative array"""
    def __getitem__(self, key): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def count(self): ...

class IviContainer(PropertyCollection):
    def _add_method(self, name: str, f: Optional[Callable] = None, doc: Optional[str] = None) -> None: ...
    
    @overload
    def _add_property(self, name: str, fget: Optional[Callable[[], T]] = None, fset: Optional[Callable[[T], None] ] =None, 
                      fdel: Optional[Callable[[], None]] = None, doc: Optional[str] = None) -> None: ...
    @overload
    def _add_property(self, name: str, fget: Optional[Callable[[Index], T]] = None, fset: Optional[Callable[[Index, T], None] ] =None, 
                      fdel: Optional[Callable[[Index], None]] = None, doc: Optional[str] = None) -> None: ...
    def _add_property(self, name: str, fget: Any = None, fset: Any = None, fdel: Any = None, doc: Optional[str] = None) -> None: ...

class Doc:
    """IVI documentation object"""
    def __init__(self, doc: str = '', cls: str = '', grp: str = '', section: str = '', name: str = '') -> None: ...
    def render(self) -> str: ...

def add_attribute(obj: IviContainer, name: str, attr, doc: Optional[str] = None): ...
def add_method(obj: IviContainer, name: str, f: Callable, doc: Optional[str] = None): ...
def add_property(obj: IviContainer, name: str, fget: Callable, fset: Optional[Callable] = None, fdel: Optional[Callable] = None, doc: Optional[str] = None): ...
def add_group_capability(obj: IviContainer , cap: str): ...

def build_ieee_block(data: bytes) -> bytes:
    """Build IEEE block"""
def decode_ieee_block(data: bytes) -> bytes:
    """Decode IEEE block"""

# TODO
def get_sig(sig):
    """Parse various signal inputs into x and y components"""
def rms(y):
    """Calculate the RMS value of the signal"""

def trim_doc(docstring: str) -> str: ...
def doc(obj, itm, docs, prefix) -> Any:
    """Python IVI documentation generator"""
def help(obj, item, complete, indent) -> Any:
    """Python IVI help system"""
def list_resources() -> list[str]: ...

class IviDriverOperation:
    cache: bool
    
    driver_setup: Final[str] 
    interchange_check: bool
    logical_name: Final[str]
    query_instrument_status: bool
    range_check: bool
    record_coercions: bool
    io_resource_descriptor: Final[str]
    simulate: Final[str]

    def clear_interchange_warnings(self) -> None: ...
    def get_next_coercion_record(self) -> str: ...
    def get_next_interchange_warning(self) -> str: ...
    def invalidate_all_attributes(self) -> None: ...
    def reset_interchange_check(self) -> None: ...

class DriverOperation(IviContainer):
    """Inherent IVI methods for driver operation"""
    driver_operation: IviDriverOperation
    
    _driver_operation_cache: bool
    _driver_operation_driver_setup: str
    _driver_operation_interchange_check: bool
    _driver_operation_logical_name: str
    _driver_operation_query_instrument_status: bool
    _driver_operation_range_check: bool
    _driver_operation_record_coercions: bool
    _driver_operation_io_resource_descriptor: str
    _driver_operation_simulate: bool
    _driver_operation_interchange_warnings: list # TODO
    _driver_operation_coercion_records: list # TODO

    def __init__(self, *args, **kwargs) -> None: ...
    def _get_driver_operation_cache(self) -> bool: ...
    def _set_driver_operation_cache(self, value: bool) -> None: ...
    def _get_driver_operation_driver_setup(self) -> str: ...
    def _get_driver_operation_interchange_check(self) -> bool: ...
    def _set_driver_operation_interchange_check(self, value: bool) -> None: ...
    def _get_driver_operation_logical_name(self) -> str: ...
    def _get_driver_operation_query_instrument_status(self) -> bool: ...
    def _set_driver_operation_query_instrument_status(self, value: bool) -> None: ...
    def _get_driver_operation_range_check(self) -> bool: ...
    def _set_driver_operation_range_check(self, value: bool) -> None: ...
    def _get_driver_operation_record_coercions(self) -> bool: ...
    def _set_driver_operation_record_coercions(self, value: bool) -> None: ...
    def _get_driver_operation_io_resource_descriptor(self) -> str: ...
    def _get_driver_operation_simulate(self) -> bool: ...
    def _set_driver_operation_simulate(self, value: bool) -> None: ...
    def _driver_operation_clear_interchange_warnings(self) -> None: ...
    def _driver_operation_get_next_coercion_record(self): ...
    def _driver_operation_get_next_interchange_warning(self): ...
    def _driver_operation_invalidate_all_attributes(self) -> None: ...
    def _driver_operation_reset_interchange_check(self) -> None: ...

class IviDriverIdentity:
    description: Final[str]
    identifier: Final[str]
    revesion: Final[str]
    vendor: Final[str]
    instrument_manufacturer: Final[str]
    instrument_model: Final[str]
    instrument_firmware_revision: Final[str]
    specification_major_version: Final[int]
    specification_minor_version: Final[int]
    supported_instrument_models: Final[str]
    group_capabilities: Final[str]

    def get_group_capabilities(self) -> list[str]: ...
    def get_supported_instrument_models(self) -> list[str]: ...

class DriverIdentity:
    """Inherent IVI methods for identification"""
    identity: IviDriverIdentity

    _identity_description: str
    _identity_identifier: str
    _identity_revision: str
    _identity_vendor: str
    _identity_instrument_manufacturer: str
    _identity_instrument_model: str
    _identity_instrument_firmware_revision: str
    _identity_specification_major_version: int
    _identity_specification_minor_version: int
    _identity_supported_instrument_models: list[str]
    
    def _add_group_capability(self, name: str) -> None: ...
    def _get_identity_description(self) -> str: ...
    def _get_identity_identifier(self) -> str: ...
    def _get_identity_revision(self) -> str: ...
    def _get_identity_vendor(self) -> str: ...
    def _get_identity_instrument_manufacturer(self) -> str: ...
    def _get_identity_instrument_model(self) -> str: ...
    def _get_identity_instrument_firmware_revision(self) -> str: ...
    def _get_identity_specification_major_version(self) -> int: ...
    def _get_identity_specification_minor_version(self) -> int: ...
    def _get_identity_supported_instrument_models(self) -> str: ...
    def _get_identity_group_capabilities(self) -> str: ...
    def _identity_get_group_capabilities(self) -> list[str]: ...
    def _identity_get_supported_instrument_models(self) -> list[str]: ...

class IviDriverUtility:
    def disable(self) -> None: ...
    def error_query(self) -> str: ...
    def lock_object(self) -> None: ...
    def reset(self) -> None: ...
    def reset_with_defaults(self) -> None: ...
    def unlock_object(self) -> None: ...

class DriverUtility(IviContainer):
    utility: IviDriverUtility
    """Inherent IVI utility methods"""
    def _utility_disable(self) -> None: ...
    def _utility_error_query(self) -> str: ...
    def _utility_lock_object(self) -> None: ...
    def _utility_reset(self) -> None: ...
    def _utility_reset_with_defaults(self) -> None: ...
    def _utility_self_test(self): ...
    def _utility_unlock_object(self) -> None: ...

class IviInherentAttribute(TypedDict, total=False):
    """Inherent IVI methods for all instruments"""
    range_check: bool # does this comment 
    query_instr_status: bool
    cache: bool
    simulate: bool
    record_coercions: bool
    interchange_check: bool
    driver_setup: Any
    prefer_pyvisa: bool

class Driver(DriverOperation, DriverIdentity, DriverUtility):
    """Inherent IVI methods for all instruments"""
    initialized: Final[bool] 

    def initialize(self, **kwargs: Unpack[IviInherentAttribute]) -> None: ...
    def close(self) -> None: ...

    _interface: Any
    _initialized: bool
    _cache_valid: dict[str, bool]
    _prefer_pyvisa: bool
    _initialized_from_constructor: bool
    def __init__(self, resource=None, id_query: bool = False, reset: bool = False, *args, **kwargs) -> None: ...
    def __del__(self) -> None: ...
    _pyvisa_opts: dict
    _driver_operation_range_check: bool
    _driver_operation_query_instrument_status: bool
    _driver_operation_cache: bool
    _driver_operation_simulate: bool
    _driver_operation_record_coercions: bool
    _driver_operation_interchange_check: bool
    _driver_operation_driver_setup: Any
    _driver_operation_io_resource_descriptor: str
    def _initialize(self, resource=None, id_query: bool = False, reset: bool = False, **keywargs) -> None:
        """Opens an I/O session to the instrument."""
    def _close(self) -> None:
        """Closes an IVI session"""
    def _get_initialized(self):
        """Returnes initialization state of driver"""
    def _get_cache_tag(self, tag: Optional[str] = None, skip: int = 1) -> str: ...
    def _get_cache_valid(self, tag: Optional[str] = None, index: int = -1, skip_disable: bool = False): ...
    def _set_cache_valid(self, valid: bool = True, tag: Optional[str] = None, index: int = -1): ...
    def _driver_operation_invalidate_all_attributes(self) -> None: ...
    def _write_raw(self, data: bytes) -> None:
        """Write binary data to instrument"""
    def _read_raw(self, num: int = -1) -> bytes:
        """Read binary data from instrument"""
    def _ask_raw(self, data: bytes, num: int = -1) -> bytes:
        """Write then read binary data"""
    def _write(self, data: str | tuple[str, ...] | list[str], encoding: str = "utf-8") -> None:
        """Write string to instrument"""
    def _read(self, num: int = -1, encoding: str = "utf-8") -> str: ...
    @overload
    def _ask(self, data: str, num: int = -1, encoding: str = "utf-8") -> str: ...
    @overload
    def _ask(self, data: tuple[str, ...] | list[str], num: int = -1, encoding: str = "utf-8") -> list[str]:
        """Write then read string"""
    def _ask_for_values(self, msg: str, delim: str = ",", converter: type = float, array: bool = True) -> None:  # TODO
        """
        write then read a list or array of data
        
        Parameters
        --------------
        msg : str
            message to write to instrument
        delim : str
            delimeter
        converter : type
            a datatype used to typecase the elements in the returned list
        array: bool
            convert the output to a numpy array 
        
        """
    def _read_stb(self) -> int:
        """Read status byte"""
    def _trigger(self) -> None:
        """Device trigger"""
    def _clear(self) -> None:
        """Device clear"""
    def _remote(self):
        """Device set remote"""
    def _local(self) -> None:
        """Device set local"""
    def _read_ieee_block(self) -> bytes:
        """Read IEEE block"""
    def _ask_for_ieee_block(self, data: str | tuple[str, ...] | list[str], encoding: str = "utf-8") -> bytes:
        """Write string then read IEEE block"""
    def _write_ieee_block(self, data: bytes, prefix: str | bytes | None = None, encoding: str = "utf-8") -> None:
        """Write IEEE block"""
    def doc(self, obj: Any, itm: Any, docs: Any, prefix: Any) -> Any: # TODO
        """Python IVI documentation generator"""
    def help(self, itm: Any, complete: Any, indent: Any) -> Any: # TODO
        """Python IVI help system"""
